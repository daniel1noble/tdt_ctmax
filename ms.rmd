---
title: ""
author: et al. 
date: "`r Sys.Date()`"
bibliography: ./bib/refs.bib
csl: ./bib/ecology-letters.csl
output: 
  bookdown::word_document2:
    toc: no
    toc_depth: 6
    number_sections: false
    reference_docx: ./bib/template.docx
  bookdown::html_document2:
    code_folding: hide
    number_sections: no
    toc: yes
    toc_depth: 6
    toc_float: yes
    bibliography: refs.bib
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE, tidy = TRUE, fig.width = 10)
## numbers >= 10^5 will be denoted in scientific notation,		  ## numbers >= 10^5 will be denoted in scientific notation,
  ## and rounded to 2 digits		  ## and rounded to 2 digits
  options(digits = 2)

##################################
# Clean workspace
##################################
    rm(list=ls())

##################################
# Loading packages & Functions
##################################
    pacman::p_load(tidyverse,  metafor, flextable,  patchwork, ggtree, ape, phytools, viridis, MCMCglmm, brms, latex2exp, orchaRd, multcomp)

```


```{r, tree}
# Bring in the fly tree
  tree <- read.tree("./phylogeny/drosi2.tre")

# Plot the tree
  plot(tree, cex = 0.2)

# Ultrametric?
  is.ultrametric(tree) # nope
  tree2 <- force.ultrametric(tree, method = "extend")

# Grab out data
   data <- read.csv("./data/drosi_data.csv")

# functions
  source("./R/func.R")
  t <- tree_checks(tree2, data = data, dataCol = "species", type = "check")
  data <- data %>% mutate(species = gsub(" ", "", species),
                          phylo = species,
                          obs = 1:n()) %>% filter(!species %in% t$Species_InData_But_NotTree) 
  tree3 <- tree_checks(tree2, data = data, dataCol = "species", type = "prune")
  tree_checks(tree3, data = data, dataCol = "species", type = "check")

  # Grab phylo matrix
  phy_vcv <- vcv(tree3, cor = FALSE)
  tree3$node.label <- NULL

```


```{r, models}

### MCMCglmm Bayesian models. Deals with missing data using data augmentation

rerun = FALSE
if(rerun){
    prior = list(R = list(V = diag(3), nu=1.002), 
               G = list(G1=list(V = diag(3), nu = 1.002)))
  
  data$animal = data$phylo
  
  mcmcglmm_model <- MCMCglmm::MCMCglmm(cbind(ctmax, cfts, tdt_z) ~ -1 + trait, random = ~us(trait):animal, rcov = ~us(trait):units ,pedigree=tree3,burnin=1000, nitt = 300000, thin = 5, family = rep("gaussian", 3), prior = prior, pl = TRUE, pr = TRUE, data = data)
  
  # We'll also z-transform to make the correlation easier to calculate. 
  data <- data %>% mutate(z_ctmax = scale(ctmax),
                           z_cfts = scale(cfts),
                          z_tdt_z = scale(tdt_z))
  
  mcmcglmm_model_z_trans <- MCMCglmm::MCMCglmm(cbind(z_ctmax, z_cfts, z_tdt_z) ~ -1 + trait, random = ~us(trait):animal, rcov = ~us(trait):units, pedigree=tree3,burnin=1000, nitt = 300000, thin = 5, family = rep("gaussian", 3), prior = prior, pl = TRUE, pr = TRUE, data = data)
  
  # Ditch phylogeny to see if there is support for including it or not. DIC is WAY lower for phylogenetic model, so good to include it.
  prior2 = list(R = list(V = diag(3), nu=1.002))
  mcmcglmm_model_z_trans_nophylo <- MCMCglmm::MCMCglmm(cbind(z_ctmax, z_cfts, z_tdt_z) ~ -1 + trait, rcov = ~us(trait):units, pedigree=tree3,burnin=1000, nitt = 300000, thin = 5, family = rep("gaussian", 3), prior = prior2, pl = TRUE, pr = TRUE, data = data)
  
  saveRDS(mcmcglmm_model, file = "./output/model/mcmcglmm_model")
  saveRDS(mcmcglmm_model_z_trans, file = "./output/model/mcmcglmm_model_z_trans")
  saveRDS(mcmcglmm_model_z_trans_nophylo, file = "./output/model/mcmcglmm_model_z_trans_nophylo")
} else{
                mcmcglmm_model <- readRDS("./output/model/mcmcglmm_model")
        mcmcglmm_model_z_trans <- readRDS("./output/model/mcmcglmm_model_z_trans")
mcmcglmm_model_z_trans_nophylo <- readRDS("./output/model/mcmcglmm_model_z_trans_nophylo")
}

```

```{r, posteriors}

# Extract posterior estimates
  sol <- mcmcglmm_model$Sol
  vcv <- mcmcglmm_model$VCV

# Extract the estimated / imputed Z for each species, but drop internal ancestral nodes
  z_blups <- sol[, grep("traittdt_z.animal", colnames(sol))]
  z_blups <- z_blups[,-grep("Node", colnames(z_blups))]
  head(z_blups)

# Remember that these are BLUPs. They are deviations from the intercept. So, to get back to the z we need to add the intercept to each of them.
  z <- z_blups + sol[, "traittdt_z"]

# Clean up names so they are just species names
  colnames(z) <- gsub("traittdt_z.animal.", "", colnames(z))

# Have a look at how well the model gets the actual data correct.
  z_known <- data %>% filter(!is.na(tdt_z)) %>% dplyr::select(species, tdt_z) %>% distinct()
    z_est <- apply(z, 2, function(x) median(x))
    z_est <- z_est[which(colnames(z) %in% z_known$species)]
    z_est <- data.frame(z_est)
    z_est$species <- row.names(z_est)
  check_z <- left_join(z_known, z_est, by = "species")

  # Check phylogeneic signal. Need to think about the covariance here. 
    # CTMax - Yes
      phylo_ctmax <- vcv[,"traitctmax:traitctmax.animal"]
      units_ctmax <- vcv[,"traitctmax:traitctmax.units"]
      
      h2_ctmax = phylo_ctmax / (phylo_ctmax + units_ctmax)
      posterior.mode(h2_ctmax)
      HPDinterval(h2_ctmax)
    
    # CFL - Yes
      phylo_cfls <- vcv[,"traitcfts:traitcfts.animal"]
      units_cfls <- vcv[,"traitcfts:traitcfts.units"]
      
      h2_cfls = phylo_cfls / (phylo_cfls + units_cfls)
      posterior.mode(h2_cfls)
      HPDinterval(h2_cfls)
      
    # z - Yes
      phylo_z <- vcv[,"traittdt_z:traittdt_z.animal"]
      units_z <- vcv[,"traittdt_z:traittdt_z.units"]
      
      h2_z = phylo_z / (phylo_z + units_z)
      posterior.mode(h2_z)
      HPDinterval(h2_z)
```


## References
